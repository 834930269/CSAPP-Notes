# Ch4 Processor Architecture

## 4.3 Sequential Y86-64 Implementations

**Organizing Processing into Stages**

处理一条指令包括许多操作，将这些操作组织成不同的阶段序列，每一阶段的具体处理取决于正在执行的指令。虽然指令的阶段的存在很大差异，但是所有的指令都遵循阶段的规则，根据这样的规则创建的框架，能设计一个充分利用硬件的处理器。

在 Y86-64 中，各个阶段为：

1. Fetch。取指，从 PC 寄存器指向的内存读取指令字节，取出指令的前两个四位部分，分别为 icode 和 ifun；还可能取出寄存器指示符字节，指明了该指令可能涉及的一个或两个寄存器；还可能取出四字节的一个常数，然后按照当前指令的地址和长度计算下一条指令的地址。
2. Decode。译码，从取指阶段的寄存器文件读入最多两个操作数；
3. Execute。执行，根据指令的定义，ALU 执行相应的操作；
4. Memory。访存，可以将数据写入内存，或者是从内存中读数据；
5. Write Back。写回，最多可以将两个结果写回到寄存器文件；
6. PC update，将 PC 更新成下一条指令的地址。

处理器无限循环执行上述阶段，发生异常时（例如 halt 指令，非法指令，读或写非法地址），处理器会停止操作；在更复杂的涉及中，发生异常会进入异常处理模式。

执行一条指令的操作复杂，不仅需要执行指令，还需要计算地址、更新栈指针、确定下一条指令的地址。因此涉及硬件时要更可能降低复杂度，例如每个处理器仅含一个 ALU，是为了硬件成本和复杂性的考量。



书上讲 Y86-64 常见指令拆解成不同的阶段，类别如下：

* OPq（整数和逻辑运算）、rrmovq（寄存器-寄存器传送）、irmovq（立即数-寄存器传送）；
* rmmovq（寄存器-内存传送）、mrmovq（内存-寄存器传送）；
* pushq、popq
* jxx Dest（跳转指令）、call dest、ret
    * 其中，call 、 ret 指令和 pushq、popq 指令类似，call 和 ret 对 PC 值进行 push 和 pop 操作。