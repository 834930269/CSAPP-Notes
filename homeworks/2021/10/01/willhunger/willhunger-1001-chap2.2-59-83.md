# Ch2 Representing and Manipulating Information

## 2.2 Integer Presentations

本节主要谈论了无符号数，补码表示的有符号数的编码方式、转换方式及扩展、阶段等。  

无符号数的编码：
$$
\text{For vector } \vec x = [x_{w - 1}, x_{w - 2}, ... x_{0}]:
\\
\text{B2U}_{w}(\vec x) = \sum_{i=0}^{w - 1}x_{i}2^{i}
$$
补码表示的有符号数的编码：
$$
\text{For vector } \vec x = [x_{w - 1}, x_{w - 2}, ... x_{0}]:
\\
\text{B2T}_{w}(\vec x) = -x_{w - 1}2^{w - 1}  + \sum_{i=0}^{w - 2}x_{i}2^{i}
$$
编码格式的不同以及不同类型的表示范围不同，程序员不能假定可表示值的特定范围；因此，C 中定义好了固定长度的几种类型，分别为：`int32_t`，`uint32_t` ，`int64_t`，`uint64_t`。



有符号数和无符号数的转换规则如下：

* 有符号数转为无符号数：
    $$
    \text{T2U}_{w}(x) = \{ ^{x + 2_{w}, \text{ x < 0}}_{x, \text{ x >= 0}}
    $$
    

* 无符号数转为有符号数：
    $$
    \text{U2T}_{w}(u) = \{ ^{u, \text{ u <= TMAX}_{w}}_{u - 2_{w}, \text{ u > TMAX}_{w}}
    $$

在 C 中，当有符号数和无符号数进行运算时，有符号数会先隐式转换了无符号数，然后再进行运算。



数的扩展：类型提升以后，

* 无符号数：直接将高位填充 0；
* 有符号数：在新增的高位上填充为原来的数的符号位

数的截断：类型降低以后，截断高位。



对于无符号数和有符号数，常常存在隐式转换导致产生难以发现定位的 bug，因此，

* 避免使用无符号数。有符号数到无符号数的隐式转换导致错误，例如 Java 就只支持有符号数；
* 当仅仅使用数字中的字节时，就使用无符号数，例如 C++ 中的 bitset。

