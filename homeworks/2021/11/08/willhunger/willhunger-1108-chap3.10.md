# Ch3 Machine-Level Representation of Programs

## 3.10 Combining Control and Data in Machine-Level Programs

**内存引用越界和缓冲区溢出**

C 对数组的引用不进行边界检查，且局部变量和状态信息都存放在栈中，写越界的数组元素会破坏存储在栈中的状态信息，当使用这个被破坏的状态信息，去重新加载寄存器或执行 $ret$ 指令时，会发生严重错误。

一种常见的错误时缓冲区溢出（buffer overflow），例如，在栈中分配字符数组来，使用 gets 函数时，如果超过了字符数组的长度，往往发生缓冲区溢出。

缓冲区溢出可以使得程序执行一些攻击代码，通常的一种做法是：用一个指向攻击代码的指针覆盖返回地址，这样就能使得代码跳转执行攻击代码，

**解决缓冲区溢出的方法**

1. 栈随机化
    * 使栈的地址在程序每次运行的地址都会有变化。具体的实现方式时：在栈上分配一个随机大小的空间，程序不使用这段空间，但是会导致程序每次执行时的栈位置发生变化。该方法需要在分配的空间大小和不浪费存储空间之中进行 trade off。
    * Linux 中，采用地址空间布局随机化（Address-Space Layout Randomization，ASLR），每次运行程序的不同部分，程序的 `.text`，`.data`，`.bss`，`.stack`，`.heap` 段，都会被加载到内存的不同区域。
    * 攻击者可以在攻击代码前加入 $nop$ 指令，该指令不断使得 rip 寄存器加一。只要攻击者能猜到这段序列中的某个地址，程序就能到达攻击代码。因此，栈随机化也不能提供完全的安全保障。