# Chapter.7 链接

- 1. 理解连接器将帮助你构造大型程序
- 2. 理解连接器将帮助你避免一些危险的编译错误
- 3. 理解链接将帮助你理解语言的作用域规则是如何实现的
- 4. 理解链接将帮助你理解其他重要的系统概念
- 5. 理解链接将使你能够利用共享库

--------------

## 符号和符号表

每个可定位目标模块`m`都有一个符号表，它包含`m`所定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号。

- 由m定义并能被其他模块引用的`全局符号`。全局链接器符号对应于非静态的C函数以及被定义为不带C的static属性的全局变量
- 由其他模块定义并被模块m引用的`全局符号`。这些符号称为`外部符号`,对应于定义在其他模块中的C函数和变量
- 只被模块m定义和引用的`本地符号`。有的本地链接器符号对应于带static属性的C函数和全局变量。这些符号在模块m中的任何地方都是可见的，但是不能被其他模块引用。

`.symtab`中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理。  
编译器在`.data`和`.bss`中为每个定义分配空间，并将其和符号表中对应的符号链接起来。 

比如

```cpp
int f(){
    static int x = 0;
    return x;
}

int g(){
    static int x = 1;
    return x;
}
```

编译器在`.bss`中为两个整数分配空间，并引出两个唯一的本地链接器符号给汇编器。

比如 `x.1` 表示f中的 `x`  
`x.2` 表示g中的 `x`

注意,在C语言中,源代码文件扮演模块的角色。而一个模块中的`static`声明的全局变量或函数是这个模块的  
未标记`static`的全局变量和函数都是`公共的`

`ELF`符号表的格式如下:  

```cpp
typedef struct{
    int name;   //字符串表偏移
    int value;  //节偏移,或者虚拟(VM)地址
    int size;   //对象的byte大小
    char type:4,    //数据,函数,节或者源文件名字(4bit)
         binding:4; //局部或者全局(4bit)
    char reserved;  //未使用
    char section;   //节头部下标,ABS.UNDEF,或者COMMON
}Elf_Symbol;
```

一个例子: 
 
![](s1.jpg)

由上图可见,每个字段的`类型`和绑定范围,以及名称和大小等都在表中


##  符号解析

链接器解析符号引用的方法是将  
每个引用  
和符号表中的对应符号  
链接起来

但是有一个问题是  
全局符号.当编译器遇到一个不属于当前模块的全局符号时，它会假定这个全局符号是其他模块的，然后生成`链接器符号表目`  

### 链接器如何解析多出定义的符号

> 1. 强弱符号

`强符号`: 函数和初始化的全局变量(包括显示初始化为0)  
`弱符号`: 未初始化的全局变量


Unix链接器使用以下规则来处理多处定义的符号  
- 1. 规则1: 不允许有多个强符号
- 2. 规则2: 如果有一个强符号和多个弱符号，那么选择弱符号
- 3. 规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个

> 示例1  

```cpp
/*fool.c*/
int main(){
    return 0;
}

/*barl.c*/
int main(){
    return 0;
}

```

编译上述两个程序,发现有两个`强符号main`,编译错误  

> 示例2

```cpp
/*foo2.c*/
int x = 15213;
int main(){
    return 0;
}

/*bar2.c*/
int x = 15213;
void f(){

}

```

编译上述两个程序,发现有两个强符号`x`,错误 

> 示例3

```cpp
/*foo2.c*/
int x = 15213;
int main(){
    return 0;
}

/*bar2.c*/
int x;
void f(){

}
```

但是,如果发现其中只有一个强符号`x`被初始化了,那么就会选择那个被初始化的`强符号x`




--------------


> Latex转Svg

https://www.latexlive.com/