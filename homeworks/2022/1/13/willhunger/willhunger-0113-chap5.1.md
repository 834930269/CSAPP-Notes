# Ch5 Optimizing Program Performance

## 5.1 Capabilities and Limitations of Optimizing Compilers

现代编译器大多都能在编译时做出一定的优化，GCC 存在不同的优化等级。

* `-Og` ：仅执行基本优化；
* `-O2` ：大多数项目采用该优化等级；
* 采用优化时，会扩大程序大小，更加难以 debug；
* 采用 O1 等级的优化，有时候可能会比更高等级的优化更加优秀。

编译器仅仅在编程语言的标准规定下，针对程序做出安全的优化，达到和未优化的版本一样的行为。程序员必须考虑并写出能让编译器优化的代码。以下为本章介绍的两种编译器无法优化的情况。

1. 内存别名（内存重叠，memory aliasing），两个指针指向同一块内存区域。例如，

    ```c
    x = 1000; y = 3000;
    *q = y; /* 3000 */
    *p = x; /* 1000 */
    t1 = *q; /* 1000 or 3000 */
    ```

    如果指针 p 和指针 q 执行同一块内存区域，上述程序的行为就不一样了。

    如果编译器不能决定两个指针是否发生了内存重叠，则其假定发生了，不会进行优化。

2. 函数调用的副作用。进行函数调用时，改变了某些全局可见状态，导致再次调用相同函数时产生不一样的行为。例如下述代码：

    ```c
    long f();
    
    long func1() {
    	return f() + f() + f() + f();
    }
    
    long func2() {
    	return 4*f();
    }
    
    long counter = 0;
    
    long f() {
     return counter++;
    }
    ```

    大多数编译器不会去决定函数调用是否会有副作用，副作用可能会发生在链接或运行时，早已经过了编译器。



内联优化(inline substitution) ：函数的代码在调用点展开，内联消除了函数调用时的额外开销，允许直接扩充代码。

* GCC 仅支持在单文件内的内联，无法支持库函数的内联；
* 内联导致无法正常使用 GDB debug 和使用 profiling 去衡量函数的性能。

